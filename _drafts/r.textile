---
title: Brief Introduction to R
layout: post
category: coding
---
p<>. R is a scripting language for statistical data manipulation and analysis getting popularity in recent years. The open-source nature means itâ€™s easy to get help from user community, and lots of new packages get contributed by users. Though the R language bears all characteristics of a programming language, to grasp the core of it should suffice for most usage scenario. This article is a brief introduction to the five most frequently-used R data structures: 

<div class="blog-post-contents">
    * "vector":#vct
    * "matrix":#mx
    * "list":#lst
    * "data.frame":#df
    * "factor":#fct
</div>

p<>. We shall browser through them one by one.

<h4 id=vct>__**Vector**__</h4>

p<>. Objects are actually considered one-element vectors, so there is really no such thing as a scalar:

bc.. > 1
[1] 1

p<>. A vector is frequently declared by the primitive function __c__:

bc.. > vct <- c(1,2)
> vct
[1] 1 2 

p<>. Vector elements must be of the same mode, and the output mode of __c__ is determined by the highest mode of the components in the mode hierarchy NULL < raw < logical < integer < double < complex < character < list < expression:

bc.. > vct <- c(as.integer(1), 1)
> storage.mode(vct)
[1] "double"

p<>. Also, function __c__ works to flat recursive structures:

bc.. > vct <- c(c(1,2), 3)
> vct
[1] 1 2 3

p<>. It's worth your attention that operators and functions in R language work in a element-wise fashion based on the vector, such as:

bc.. > ifelse(c(1,2,3,4) %% 2 == 0, 'even', 'odd')
[1] "odd"  "even" "odd"  "even"

p<>. Shorter vectors would be recursively completed so as to have same length. So

bc.. > c(1,2,3,4) %% 2 == 0 
[1] FALSE  TRUE FALSE  TRUE

p<>. is actually

bc. > c(1,2,3,4) %% c(2,2,2,2) == c(0,0,0,0)
[1] FALSE  TRUE FALSE  TRUE

<h4 id=mx>__**Matrix**__</h4>

p<>. An array is a vector with a "dim" attribution. A two-dimensional array is called matrix, which is eligible for the usual matrix mathematical operations. For instance:

bc.. > mx <- matrix(1:9, nrow=3, ncol=3)
> mx
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9

> mx %*% mx
     [,1] [,2] [,3]
[1,]   30   66  102
[2,]   36   81  126
[3,]   42   96  150

p<>. One could select a slice of a matrix with a vector as the row indices and column indices:

bc.. > mx[c(1,2), c(1,3)]
     [,1] [,2]
[1,]    1    7
[2,]    2    8

p<>. While, if one selects a single row or column from a matrix, something undesirable happends:

bc.. > r <- mx[1,]
> attributes(r)
NULL

p<>. The return is no longer a matrix. To avoid this, one could sepcify the "drop" parameter:

bc.. > r <- mx[1, , drop=FALSE]
> attributes(r)
$dim
[1] 1 3

p<>. Than, r is still a matrix.

<h4 id=lst>__**List**__</h4>

p<>. Other than the vector or matrix whose elements are of the same mode, list is prettey much like C **struct**. The components of a list could have distinct modes. One may initiate a list in this way:

bc.. > lst <- list(name="Joe", salary=55000)
> lst
$name
[1] "Joe"

$salary
[1] 55000

p<>. Elements of a list can be accessed by [['elmt name']] or [[elmt index]]:

bc.. > lst[['name']]
[1] "Joe"

> lst[[1]]
[1] "Joe"

p<>. To get a slice of a list, substitute ['elmt name'] or [elmt index] with a vector of element names or indices:

bc.. > lst[c('name','salary')]
$name
[1] "Joe"

$salary
[1] 55000

> lst[c(1,2)]
$name
[1] "Joe"

$salary
[1] 55000

p<>. The reture is still a list:

bc. > class(lst[1])
[1] "list"

<h4 id=df>__**Data.frame**__</h4>
